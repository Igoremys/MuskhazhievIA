# Отчет по лабораторной работе №9
# Исследование алгоритмов динамического программирования

**Дата:** 2025-12-10
**Семестр:** 3 курс, 1 полугодие (5 семестр)
**Группа:** ПИЖ-б-о-23-2(2)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Мусхажиев Игорь Александрович

---

## Цель работы
Изучить метод динамического программирования (ДП) как инструмент решения сложных задач путём разбиения их на перекрывающиеся подзадачи. Освоить два основных подхода — восходящий (bottom-up) и нисходящий (top-down с мемоизацией). Получить практические навыки в построении оптимальной подструктуры, анализе временной и пространственной сложности, восстановлении решений и проведении экспериментов.

---

## Теоретическая часть
В работе реализованы и проанализированы следующие классические задачи ДП:

- Числа Фибоначчи (три подхода: наивная рекурсия, мемоизация, bottom-up)  
- Задача о рюкзаке (0–1) — с восстановлением выбранных предметов  
- Наибольшая общая подпоследовательность (LCS) — с восстановлением самой подпоследовательности  
- Расстояние Левенштейна  
- Размен монет (минимальное количество монет)  
- Наибольшая возрастающая подпоследовательность (LIS)  

Также проведено сравнение подходов, пространственная оптимизация рюкзака до O(W), визуализация таблиц ДП и эксперименты по масштабируемости.
---

## Практическая часть

### Выполненные задачи
- [x] Реализованы все алгоритмы ДП  
- [x] Реализованы оба подхода (top-down и bottom-up) для Фибоначчи  
- [x] Проведён сравнительный анализ времени и памяти  
- [x] Восстановлены решения для рюкзака и LCS  
- [x] Решены практические задачи: размен монет, LIS  
- [x] Реализована пространственная оптимизация рюкзака  
- [x] Визуализация таблицы ДП  
- [x] Проведены эксперименты по масштабируемости  


---

## Характеристики ПК для тестирования

```
Процессор: 12th Gen Intel(R) Core(TM) i5-12400F 
Оперативная память: 16 GB DDR4
ОС: Windows 10 
Python: 3.13.1
```

---

## Ключевые фрагменты кода


```python
# Оптимизированный bottom-up Фибоначчи (O(1) памяти)
def fib_bottom_up(n: int) -> int:
    if n <= 1:
        return n
    prev, curr = 0, 1
    for _ in range(2, n + 1):
        prev, curr = curr, prev + curr
    return curr

# Рюкзак 0–1 с восстановлением решения
def knapsack_01(weights, values, capacity):
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            if weights[i - 1] <= w:
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:
                dp[i][w] = dp[i - 1][w]

    # Восстановление набора предметов
    chosen = []
    i, w = n, capacity
    while i > 0 and w > 0:
        if dp[i][w] != dp[i - 1][w]:
            chosen.append(i - 1)
            w -= weights[i - 1]
        i -= 1
    return dp[n][capacity], chosen[::-1]
```

---

## Результаты выполнения

```bash
**Входные данные:**  
- Предметы: `[(w=2, v=12), (w=1, v=10), (w=3, v=20), (w=2, v=15)]`  
- Вместимость: `5`

**Таблица `dp`:**

=== Итоговая таблица ===
0 | 0 |  0 |  0 |  0 |  0 |
0 | 0 |  0 |  0 |  0 |  0 |
0 | 0 |  0 |  0 |  0 |  0 |
0 | 0 | 18 | 18 | 18 | 18 |
0 | 0 | 18 | 18 | 30 | 30 |
Оптимальная стоимость: 35
```

---

## Выводы
1. Bottom-up ДП работает быстрее и эффективнее по памяти.  
2. Мемоизация полезна, но уступает по производительности.  
3. Жадный алгоритм рюкзака быстрый, но не решает 0–1 задачу корректно.  

---

## Контрольные вопросы
1. **Какие два основных свойства задачи указывают на то, что для её решения можно применить динамическое программирование?** 
   - Оптимальная подструктура: оптимальное решение включает оптимальные решения подзадач.
   - Перекрывающиеся подзадачи: одни и те же подзадачи решаются многократно.


2. **Разница между top-down и bottom-up?** 
   - Top-down — рекурсия + мемоизация, вычисляются только необходимые подзадачи
   - Bottom-up — итеративное заполнение таблицы от простого к сложному, без рекурсии

3. **Как задача о рюкзаке 0–1 демонстрирует оптимальную подструктуру?**

- Оптимальный выбор для ёмкости W строится либо без i-го предмета, либо с ним, добавляя к оптимальному решению для ёмкости W − w[i].

4. **Как строится таблица для LCS?**

- Строится матрица, где каждая ячейка отражает длину LCS для префиксов двух строк. Таблица заполняется последовательно: если текущие символы совпадают, значение увеличивается на единицу относительно диагонали; если нет — выбирается максимум из значений сверху или слева. В конце последняя ячейка содержит длину LCS.

5. **Как динамическое программирование уменьшает сложность вычисления Фибоначчи?**

- Устраняет экспоненциальное дублирование подвычислений, снижая сложность с O(2ⁿ) до O(n) по времени и O(1) по памяти.

---

## Приложения
- Файлы проекта:
  - `dynamic_programming.py`
  - `comparison.py`
  - `experiments.py`
  - `solutions.py`
  - `visualizer.py`
- Графики:
  - `knapsack_time.png`
