# Отчет по лабораторной работе №11
# Алгоритмы на строках

**Дата:** 2025-11-15  
**Семестр:** 3 курс, 2 полугодие (6 семестр)  
**Группа:** ПИЖ-б-о-23-2(2)  
**Дисциплина:** Алгоритмы и структуры данных  
**Студент:** Мусхажиев Игорь Александрович  

---

## Цель работы
Изучить реализацию и применение алгоритмов на строках: префикс-функции, Z-функции, алгоритма Кнута–Морриса–Пратта (KMP), а также одного из дополнительных методов поиска подстроки (Rabin–Karp). Освоить методы поиска подстрок, анализа периодичности и циклических сдвигов. Получить практические навыки реализации, тестирования и сравнительного анализа эффективности алгоритмов обработки строк.

---

## Теоретическая часть
- **Префикс-функция** для строки `S` — массив `π[0..n−1]`, где `π[i]` — длина наибольшего собственного префикса подстроки `S[0..i]`, который одновременно является её суффиксом. Вычисляется за **O(n)**.
- **Алгоритм KMP** использует префикс-функцию для поиска всех вхождений образца в тексте за **O(n + m)**, избегая возвратов по тексту.
- **Z-функция** — массив `z[0..n−1]`, где `z[i]` — длина наибольшего общего префикса строк `S` и `S[i..n−1]`. Также вычисляется за **O(n)**.
- **Алгоритм Рабина–Карпа** использует хеширование для поиска подстроки. Средняя сложность — **O(n + m)**, худший случай — **O(n·m)** (редко при хорошем хеше).
- Все алгоритмы линейны в среднем, но ведут себя по-разному на специфических входах (повторяющиеся символы, случайные строки и т.п.).

---

## Практическая часть

### Выполненные задачи
- [x] Задача 1: Реализация вычисления префикс-функции  
- [x] Задача 2: Реализация алгоритма KMP для поиска подстроки  
- [x] Задача 3: Реализация вычисления Z-функции  
- [x] Задача 4: Реализация алгоритма Рабина–Карпа  
- [x] Задача 5: Поиск всех вхождений подстроки в тексте  
- [x] Задача 6: Нахождение минимального периода строки  
- [x] Задача 7: Проверка, является ли одна строка циклическим сдвигом другой

---

### Ключевые фрагменты кода


```python
# prefix_function.py
def prefix_function(s: str) -> list[int]:
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i - 1]
        while j > 0 and s[i] != s[j]:
            j = pi[j - 1]
        if s[i] == s[j]:
            j += 1
        pi[i] = j
    return pi
```

```python
# kmp_search.py
def kmp_search(text: str, pattern: str) -> list[int]:
    if not pattern:
        return list(range(len(text) + 1))
    s = pattern + '#' + text
    pi = prefix_function(s)
    matches = []
    m = len(pattern)
    for i in range(m + 1, len(s)):
        if pi[i] == m:
            matches.append(i - 2 * m)
    return matches
```
---

## Результаты выполнения

### Пример работы программы
```bash
$ python tasks/find_all_occurrences.py
[0, 4, 8]

$ python tasks/minimal_period.py
4

$ python tasks/cyclic_shift.py
True

```

---

### Характеристики ПК для тестирования
```
Процессор: 12th Gen Intel(R) Core(TM) i5-12400F 
Оперативная память: 16 GB DDR4
ОС: Windows 10
Python: 3.13.1
```

---

## Выводы
1. Алгоритм KMP стабильно работает за линейное время и предпочтителен при детерминированной гарантии производительности.
2. Z-функция удобна для задач, где требуется множество запросов на префиксы суффиксов (например, поиск всех периодов).
3. Rabin–Karp эффективен при поиске множества образцов (через хеши) и в среднем быстр, но уязвим к худшим случаям без рандомизации.
4. Практические задачи (поиск периода, циклический сдвиг) решаются элегантно и эффективно с помощью префикс-функции.
5. Производительность сильно зависит от структуры входных данных: на случайных строках все алгоритмы близки по времени, на вырожденных — KMP выигрывает.

---