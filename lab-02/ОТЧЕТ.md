# Отчет по лабораторной работе №2
# Основные структуры данных. Анализ и применение

**Дата:** 2025-10-16  
**Семестр:** 3 курс, 5 семестр  
**Группа:** ПИЖ-б-о-23-2(2) 
**Дисциплина:** Анализ сложности алгоритмов  
**Студент:** Мусхажиев Игорь Александрович

---

## Цель работы
Изучить понятие и особенности базовых абстрактных типов данных — стек, очередь, дек, связный список — и их реализаций в Python.  
Научиться выбирать оптимальную структуру данных для решения задач на основе анализа теоретической и практической сложности операций.  
Провести измерение производительности и применить структуры данных для практических задач.

---

## Теоретическая часть
В рамках лабораторной работы были изучены следующие структуры данных:

- **Список (`list`)** — динамический массив с амортизированной вставкой в конец за `O(1)` и доступом по индексу за `O(1)`.  
  Вставка и удаление в начале — `O(n)`.

- **Связный список (`LinkedList`)** — набор узлов (`Node`), где каждый хранит данные и ссылку на следующий элемент.  
  Вставка/удаление в начало — `O(1)`, доступ по индексу — `O(n)`.

- **Стек (`Stack`)** — структура LIFO (*последний пришёл — первый ушёл*).  
  Реализуется через `list`, операции `append()` и `pop()` — `O(1)`.

- **Очередь (`Queue`)** — структура FIFO (*первый пришёл — первый ушёл*).  
  Эффективно реализуется через `collections.deque` (операции `append()` и `popleft()` — `O(1)`).

- **Дек (`Deque`)** — двусторонняя очередь, позволяющая добавлять/удалять элементы с обеих сторон за `O(1)`.

---

## Практическая часть

### Выполненные задачи
- [x] Задача 1: Реализован класс `LinkedList` и класс `Node` (вставка, удаление, обход).  
- [x] Задача 2: Проведён анализ производительности операций:
  - `list.insert(0, x)` vs `LinkedList.insert_at_start`
  - `list.pop(0)` vs `deque.popleft()`
- [x] Задача 3: Решены практические задачи:
  - Проверка сбалансированности скобок (стек)
  - Симуляция очереди печати (deque)
  - Проверка палиндрома (deque)

---

### Ключевые фрагменты кода

#### Реализация узла и списка

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None  # Для O(1) вставки в конец

    def insert_at_start(self, data):
        """O(1)"""
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
        if self.tail is None:
            self.tail = new_node

    def insert_at_end(self, data):
        """O(1) благодаря tail"""
        new_node = Node(data)
        if self.tail is None:
            self.head = self.tail = new_node
        else:
            self.tail.next = new_node
            self.tail = new_node
```

#### Пример решения задачи проверки скобок

```python
def is_balanced_brackets(s: str) -> bool:
    stack = []
    pairs = {')': '(', ']': '[', '}': '{'}
    for ch in s:
        if ch in pairs.values():
            stack.append(ch)
        elif ch in pairs:
            if not stack or stack.pop() != pairs[ch]:
                return False
    return not stack
```

---

## Результаты выполнения

### Пример работы программы

```bash
[Вставка в начало]
list.insert(0):     ~0.048 с
LinkedList:         ~0.0008 с

[Удаление из начала]
list.pop(0):        ~0.042 с
deque.popleft():    ~0.0003 с
```

---

### Характеристики ПК для тестирования
```
Характеристики ПК для тестирования:
- Процессор: 12th Gen Intel(R) Core(TM) i5-12400F 
- Оперативная память: 16 GB DDR4
- ОС: Windows 10
- Python: 3.10.10
```

## Выводы
1. Использование list для операций в начале (вставка/удаление) неэффективно из-за линейной сложности.
2. LinkedList с tail обеспечивает O(1) для вставки в конец и начало, но проигрывает list в потреблении памяти и доступе по индексу.
3. collections.deque — оптимальный выбор для реализации очереди и дека.
4. Практические задачи (скобки, очередь, палиндром) наглядно демонстрируют, как правильный выбор структуры данных упрощает код и повышает эффективность.

---

## Ответы на контрольные вопросы

1. **В чем отличие динамического массива (`list`) от связного списка по сложности операций?**  
— list: вставка в начало — O(n), доступ по индексу — O(1).
— LinkedList: вставка в начало — O(1), доступ по индексу — O(n).

2. **Принцип работы стека и очереди, примеры использования:**  
— Стек (LIFO): отмена действий, вызов функций.
— Очередь (FIFO): обработка задач принтера, обработка запросов.

3. **Почему удаление первого элемента из списка (`list`) — O(n), а из дека (`deque`) — O(1)?**  
— В list все элементы сдвигаются влево.
— В deque используется кольцевой буфер — сдвигов нет.

4. **Какую структуру выбрать для системы отмены действий (undo)?**  
— Стек (list или deque), так как действия отменяются в обратном порядке.

5. **Почему вставка в начало списка занимает больше времени, чем в связный список?**  
— list копирует все элементы при сдвиге, LinkedList лишь меняет ссылки.
---

## Приложения
[Исходный код](linked_list.py)  
![График 1](plots/insert_start_list_vs_linkedlist.png)
![График 2](plots/queue_list_vs_deque.png)  

