# Отчет по лабораторной работе №7
# Структура данных «Куча» и пирамидальная сортировка

**Дата:** 2025-11-15  
**Семестр:** 3 курс, 2 полугодие (6 семестр)  
**Группа:** ПИЖ-б-о-23-2(2)  
**Дисциплина:** Алгоритмы и структуры данных  
**Студент:** Мусхажиев Игорь Александрович  

---

## Цель работы
Изучить структуру данных «куча», реализовать её основные операции и исследовать эффективность построения кучи и алгоритмов сортировки (Heapsort, QuickSort, MergeSort). Провести теоретический и практический сравнительный анализ, построить графики производительности и визуализировать структуру кучи.

---

## Теоретическая часть
Рассмотрены основные структуры и алгоритмы:

- **Min-heap / Max-heap** — полное бинарное дерево, удовлетворяющее свойству кучи:  
  Min-heap: родитель ≤ потомков  
  Max-heap: родитель ≥ потомков  

- **Операции кучи:**  
  `insert` — O(log n)  
  `extract` — O(log n)  
  `build_heap` — O(n)  
  `sift_up`, `sift_down` — восстановление свойства кучи  

- **Heapsort** — сортировка через max-heap, сложность O(n log n).

- **QuickSort** — рекурсивная сортировка, пивот — первый элемент,  
  средняя сложность O(n log n), худшая O(n²).

- **MergeSort** — сортировка слиянием, всегда O(n log n), требует O(n) памяти.

---

## Практическая часть

### Выполненные задачи
- [x] Реализована универсальная куча (`Heap` с параметром `is_min`)
- [x] Реализованы `sift_up`, `sift_down`, `insert`, `extract`, `peek`, `build_heap`
- [x] Реализован `heapsort` и **in-place версия**
- [x] Реализована `PriorityQueue` на основе кучи
- [x] Написаны unit-тесты (`unittest`)
- [x] Проведены замеры времени: 
- Последовательная вставка vs `build_heap`  - Heapsort vs встроенная сортировка Python (Timsort)
- [x] Построен график производительности (`performance_comparison.png`) 

---

### Ключевые фрагменты кода

### 1. Внутренний метод `_sift_down` (`heap.py`)
```python
def _sift_down(self, index):
    n = len(self.heap)    
    while True:    
        left = 2 * index + 1        
        right = 2 * index + 2        
        extremum = index        
        if left < n and self._compare(self.heap[left], self.heap[extremum]):            
            extremum = left        
        if right < n and self._compare(self.heap[right], self.heap[extremum]):           
             extremum = right       
        if extremum == index:            
            break        
        self.heap[index], self.heap[extremum] = self.heap[extremum], self.heap[index]        
        index = extremum
```

#### 2. Метод `build_heap` (heap.py)
```python
def build_heap(self, array):
    self.heap = array[:]
    for i in range((len(self.heap) - 2) // 2, -1, -1):
        self._sift_down(i)
```

#### 3.  In-place Heapsort  (heapsort.py)
```python
def heapsort_inplace(array):
    def sift_down(start, end):
        root = start
        while True:
            child = 2 * root + 1
            if child > end: break
            if child + 1 <= end and array[child] < array[child + 1]:
                child += 1
            if array[root] < array[child]:
                array[root], array[child] = array[child], array[root]
                root = child
            else:
                break

    n = len(array)
    for i in range((n - 2) // 2, -1, -1):
        sift_down(i, n - 1)
    for end in range(n - 1, 0, -1):
        array[0], array[end] = array[end], array[0]
        sift_down(0, end - 1)
```

#### 4. Приоритетная очередь (priority_queue.py)
```python
class PriorityQueue:
    def __init__(self, is_min=True):
        self.heap = Heap(is_min=is_min)

    def enqueue(self, item, priority):
        self.heap.insert((priority, item))

    def dequeue(self):
        _, item = self.heap.extract()
        return item
```
---

## Результаты выполнения

### Пример работы программы
```bash
[BUILD] n=1000: insert=0.0004s, build_heap=0.0002s  
[BUILD] n=5000: insert=0.0021s, build_heap=0.0009s  
[SORT]  n=5000: heapsort=0.0081s, timsort=0.0006s  
[COMPARE] n=2000: heap=0.0028s, quick=0.0018s, merge=0.0022s

```

---

### Характеристики ПК для тестирования
```
Процессор: 12th Gen Intel(R) Core(TM) i5-12400F 
Оперативная память: 16 GB DDR4
ОС: Windows 10
Python: 3.13.1
```

---

## Выводы
1. Построение кучи через build_heap действительно работает в 2–3 раза быстрее, чем последовательная вставка — подтверждена теоретическая оценка O(n) против O(n log n).
2. Heapsort обеспечивает стабильную сложность O(n log n) даже в худшем случае, но уступает по скорости встроенной сортировке Python (Timsort), оптимизированной под реальные данные.
3. In-place реализация не использует дополнительную память, что делает её предпочтительной при ограничениях по памяти.
4. Приоритетная очередь на основе кучи показала корректную работу и эффективность операций enqueue/dequeue за O(log n).
5. Код соответствует PEP8, снабжён комментариями и проходит все unit-тесты.

---

## Ответы на контрольные вопросы

1. **Сформулируйте основное свойство min-кучи и max-кучи.**  
    - Min-heap — значение любого узла ≤ значений его потомков → минимум в корне.

    - Max-heap — значение любого узла ≥ значений его потомков → максимум в корне.

2. **Опишите алгоритм вставки нового элемента в кучу (процедуру sift_up).**  
    1. Элемент добавляется в конец массива.
    2. Сравнивается с родителем.
    3. Если нарушает свойство кучи — меняется местами.
    4. Повторяется до восстановления свойства или достижения корня.
    Сложность: O(log n).

3. **Какова временная сложность построения кучи из произвольного массива и почему она равна O(n), а не O(n log n)?**  
    Хотя кажется, что нужно выполнить sift_down для каждого элемента массива, и каждая операция может занимать до O(log n), на практике построение кучи выполняется за O(n).
    Это происходит потому, что:
    - половина всех элементов массива — листья, и они не требуют вызова sift_down;
    - четверть — находятся на глубине 1;
    - дальше — всё меньше элементов на больших глубинах.
    Общая сумма всех затрат вычисляется как:
        (n/2)*0 + (n/4)*1 + (n/8)*2 + ... + 1*(log n)
    Эта сумма математически равна O(n). Поэтому алгоритм Флойда (build_heap) работает линейно.

4. **Опишите, как работает алгоритм пирамидальной сортировки (Heapsort).**  
    Алгоритм Heapsort состоит из двух этапов:
    1. Построение max-кучи из исходного массива — выполняется за O(n).
    2. Многократное извлечение максимального элемента:
       - Меняем местами первый (максимальный) элемент и последний.
       - Уменьшаем размер кучи на 1.
       - Вызываем sift_down(0), чтобы восстановить max-heap.
    Этот процесс повторяется, пока не будут обработаны все элементы.
    Итоговая сложность Heapsort — O(n log n).
    Сортировка выполняется in-place, не требуя дополнительной памяти (кроме O(1)).

 5. **Почему кучу часто используют для реализации приоритетной очереди? Какие операции приоритетной очереди она эффективно поддерживает?**
    Кучу используют для реализации приоритетной очереди, потому что она обеспечивает быстрый доступ к элементу с максимальным или минимальным приоритетом. Корень кучи всегда содержит элемент с наивысшим приоритетом.
    Куча эффективно поддерживает следующие операции:
    - insert(x) — вставка нового элемента, работает за O(log n);
    - extract_max() / extract_min() — извлечение элемента с максимальным/минимальным приоритетом, работает за O(log n);
    - peek() — получение элемента с высшим приоритетом без удаления, работает за O(1).
    Благодаря этим свойствам куча является оптимальной структурой данных для реализации приоритетных очередей.
