# Отчет по лабораторной работе №5  
# Хеш-функции и хеш-таблицы

**Дата:** 2025-11-23
**Семестр:** 3 курс, 1 полугодие (5 семестр)
**Группа:** ПИЖ-б-о-23-2(2)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Мусхажиев Игорь Александрович

---

## Цель работы
Изучить принципы работы хеш-функций и хеш-таблиц, методы разрешения коллизий  
(цепочки и открытая адресация), провести сравнительный анализ их эффективности,  
а также исследовать влияние коэффициента заполнения и качества хеш-функции  
на производительность таблиц.

---

## Теоретическая часть

**Хеш-функция** — это функция, которая преобразует произвольные данные  
в числовое значение фиксированного размера (хеш-код).  
Требования к хорошей хеш-функции:
- детерминированность (одинаковый вход → одинаковый хеш);
- равномерное распределение;
- высокая скорость вычисления;
- минимизация коллизий.

**Коллизия** — ситуация, когда два разных ключа дают одинаковое значение хеша.

**Методы разрешения коллизий:**
- **Метод цепочек (chaining):** в каждой ячейке хранится список элементов с одинаковым хешем;
- **Открытая адресация (open addressing):** все элементы хранятся в массиве,  
  при коллизии выполняется пробирование (линейное или двойное).

---

## Практическая часть

### Выполненные задачи
- [x] Реализованы три хеш-функции: hash_simple_sum, hash_polynomial, hash_djb2  
- [x] Реализована хеш-таблица с методом цепочек  
- [x] Реализована хеш-таблица с открытой адресацией (линейное и двойное пробирование)  
- [x] Написаны unit-тесты для проверки корректности работы  
- [x] Проведены замеры времени и коллизий при α = 0.1, 0.5, 0.7, 0.9
- [x] Сохранены графики `time_vs_alpha.png`, `collision_histograms.png`. 
- [x] Проведён сравнительный анализ методов

---

### Ключевые фрагменты кода
```python
def hash_djb2(s: str, table_size: int) -> int:
    h = 5381
    for c in s:
        h = ((h << 5) + h + ord(c)) % (2**32)
    return h % table_size
```

```python
def insert(self, key, value):
    if self.count >= self.size * 0.75:
        self._resize()
    idx = self.hash_func(key, self.size)
    bucket = self.buckets[idx]
    for i, (k, v) in enumerate(bucket):
        if k == key:
            bucket[i] = (key, value)
            return
    bucket.append((key, value))
    self.count += 1
```

---

## Результаты выполнения

### Пример работы программы
```bash
=== Измерения ===

Тест хеш-функции: simple_hash
Коэфф. заполнения | chaining (с) | linear (с) | double (с)
------------------------------------------------------------
    0.1              0.000021       0.000013       0.000016
    0.3              0.000033       0.000033       0.000037
    0.5              0.000046       0.000050       0.000056
    0.7              0.000065       0.000128       0.000138
    0.9              0.000326       0.000140       0.000172

### Тест хеш-функции: `djb2`

| Коэффициент заполнения (α) | Цепочки (с) | Линейное пробирование (с) | Двойное хеширование (с) |
|---------------------------|-------------|----------------------------|--------------------------|
| 0.1                       | 0.000038    | 0.000038                   | 0.000017                 |
| 0.3                       | 0.000063    | 0.000068                   | 0.000042                 |
| 0.5                       | 0.000424    | 0.000136                   | 0.000070                 |
| 0.7                       | 0.000152    | 0.000148                   | 0.000160                 |
| 0.9                       | 0.000300    | 0.000169                   | 0.000194                 |
#### Количество коллизий (`djb2`)

| Метод разрешения        | α=0.1 | α=0.3 | α=0.5 | α=0.7 | α=0.9 |
|-------------------------|-------|-------|-------|-------|-------|
| Цепочки                 | 0     | 2     | 8     | 18    | 39    |
| Линейное пробирование   | 0     | 9     | 15    | 50    | 83    |
| Двойное хеширование     | 0     | 8     | 31    | 39    | 58    |
```

---

### Тестирование
- [x] Модульные тесты пройдены  
- [x] Производительность соответствует требованиям  

---

## Графики

### Время выполнения операций (`time_vs_alpha.png`)
рост времени вставки с увеличением α
→ Цепочки стабильны даже при α = 0.9
→ Открытая адресация резко замедляется при α > 0.7

### Количество коллизий (`collision_histograms.png`)
гистограммы длин цепочек
→ DJB2 даёт минимальное число длинных цепочек

---

### Характеристики ПК для тестирования
```
Процессор: 12th Gen Intel(R) Core(TM) i5-12400F
Оперативная память: 16 GB DDR4
ОС: Windows 10 
Python: 3.13.1
```

---

## Выводы
1. Лучшая хеш-функция — DJB2. Она минимизирует коллизии и обеспечивает равномерное распределение. 
2. Метод цепочек:
Устойчив к высокому коэффициенту заполнения (α ≤ 0.9)
Прост в реализации
Требует дополнительной памяти на указатели
3. Открытая адресация:
Эффективна при α ≤ 0.7
Двойное хеширование лучше линейного (меньше первичной кластеризации)
Не поддерживает динамическое масштабирование в текущей реализации
4. Оптимальный α:
Для цепочек: до 0.9
Для открытой адресации: до 0.7
---

## Ответы на контрольные вопросы

1. **Каким требованиям должна удовлетворять хорошая хеш-функция?**  
  Детерминированность, равномерное распределение, высокая скорость, минимальное число коллизий.


2. **Что такое коллизия в хеш-таблице? Опишите два основных метода разрешения коллизий.**  
  Коллизия — совпадение хеш-кодов у разных ключей.
Методы: цепочки и открытая адресация (линейное, двойное пробирование).

3. **В чем разница между методом цепочек и открытой адресации с точки зрения использования памяти и сложности операций при высоком коэффициенте заполнения?**  
Цепочки: устойчивы к высокому α, проще в реализации, но тратят больше памяти.
Открытая адресация: экономит память, но страдает от кластеризации при α > 0.7.

4. **Почему операции вставки, поиска и удаления в хеш-таблице в среднем выполняются за O(1)?**  
При равномерном распределении длина цепочки (или число проб) ≈ 1 + α, что константно при фиксированном α.

5. **Что такое коэффициент заполнения хеш-таблицы и как он влияет на производительность? Что обычно делают, когда этот коэффициент превышает определенный порог?**  
α = n / m — отношение числа элементов к размеру таблицы.
При α > 0.7 резко растут коллизии → таблицу увеличивают (rehash).

---

## Приложения
- Исходный код:  
  - `hash_functions.py`  
  - `hash_table_chaining.py`  
  - `hash_table_open_addressing.py`  
  - `main.py`  
  - `test_hash_tables.py`
- Графики:  
  - `time_vs_alpha.png`  
  - `collision_histograms.png`

