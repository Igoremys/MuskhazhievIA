# Отчет по лабораторной работе 10

# Графы

**Дата:** 2025-11-06
**Семестр:** 3 курс 5 семестр
**Группа:** ПИЖ-б-о-23-2(2)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Мусхажиев Игорь Александрович


## Цель работы

Изучить основные понятия теории графов и алгоритмы работы с ними. Освоить представления графов в памяти и основные алгоритмы обхода. Получить практические навыки реализации алгоритмов на графах и анализа их сложности.

## Практическая часть

### Выполненные задачи

- [x] Реализованы два представления графа: матрица и список смежности  
- [x] Реализованы алгоритмы обхода: BFS (с восстановлением пути и расстояний), DFS (рекурсивный и итеративный)  
- [x] Реализованы алгоритмы: поиск компонент связности, топологическая сортировка, алгоритм Дейкстры  
- [x] Написаны unit-тесты для всех алгоритмов с проверкой на графах разных типов  
- [x] Проведено сравнение эффективности представлений графа по времени выполнения операций  
- [x] Выполнено экспериментальное исследование масштабируемости алгоритмов  
- [x] Построены графики зависимости времени выполнения от размера графа  

### Ключевые фрагменты кода

```PYTHON
# graph_representation.py — интерфейс графа
class GraphInterface:
    def add_edge(self, u: int, v: int, weight: float = 1) -> None: ...
    def get_neighbors(self, v: int) -> List[tuple]: ...

# shortest_path.py — Дейкстра
def dijkstra(graph: GraphInterface, start: int) -> Tuple[Dict[int, float], Dict[int, Optional[int]]]:
    pq = [(0, start)]
    distances = {}
    while pq:
        d, u = heapq.heappop(pq)
        if u in distances: continue
        distances[u] = d
        for v, w in graph.get_neighbors(u):
            if v not in distances:
                heapq.heappush(pq, (d + w, v))
    return distances, {}
# Характеристики вычислительной машины
pc_info = """
Характеристики ПК для тестирования:
- Процессор: Intel Core i5-12400F
- Оперативная память: 16 GB DDR4
- ОС: Windows 10
- Python: 3.11
"""
print(pc_info)


BFS from vertex 5: [5, 0, 2, 4, 3, 1]
DFS Recursive from vertex 5: [5, 0, 4, 1, 3, 2]
DFS Iterative from vertex 5: [5, 0, 4, 1, 3, 2]
Connected Component: [0, 4, 1, 3, 2, 5]
Shortest path from 5 to 0: 5
Shortest path from 5 to 1: 3
Shortest path from 5 to 2: 1
Shortest path from 5 to 3: 2
Shortest path from 5 to 4: 4
Shortest path from 5 to 5: 0

Graph Representation:

Adjacency Matrix:
[0, 0, 0, 0, 1, 99]
[0, 0, 0, 1, 1, 0]
[0, 0, 0, 1, 0, 1]
[0, 1, 1, 0, 0, 0]
[1, 1, 0, 0, 0, 0]
[99, 0, 1, 0, 0, 0]

Adjacency List:
0: [4, 5]
1: [3, 4]
2: [3, 5]
3: [1, 2]
4: [0, 1]
5: [0, 2]
Maze-task
Shortest path in maze from S(0) to E(5): [0, 6, 12, 13, 14, 8, 2, 3, 4, 5]


Характеристики ПК для тестирования:
- Процессор: Intel Core i5-12400F
- Оперативная память: 16 GB DDR4
- ОС: Windows 10
- Python: 3.11

```

| Операция / Характеристика     | Матрица смежности                         | Список смежности                          |
|------------------------------|--------------------------------------------|--------------------------------------------|
| **Память**                   | O(V²)                                      | O(V + E)                                   |
| **Добавление вершины**       | O(V) — нужно расширять каждую строку       | O(1) — просто создаётся новый список       |
| **Удаление вершины**         | O(V²) — удаление строки и столбца          | O(V + E) — проход по спискам               |
| **Добавление ребра**         | O(1) — просто записываем вес               | O(1) — добавляем элемент в список          |
| **Удаление ребра**           | O(1) — ставим 0                             | O(E) — поиск и удаление из списка          |
| **Проверка существования ребра** | O(1) — matrix[u][v]                        | O(deg(u)) — поиск в списке                |
| **Обход соседей вершины**    | O(V) — нужно пройти всю строку             | O(deg(u)) — только реальные соседи         |
| **Поддержка взвешенных рёбер** | Да (вес в ячейке)                          | Да (вес параллельным списком)              |
| **Лучше подходит для…**      | Плотных графов, V большое, E ≈ V²          | Разреженных графов, E << V²               |
| **Хуже подходит для…**       | Разреженных графов (растёт память)         | Графов, где важны быстрые проверки ребра  |
| **Конвертация список → матрица** | O(V²)                                    | —                                          |
| **Конвертация матрица → список** | O(V²)                                   | —                                          |



| Задача                                | Какой алгоритм применять                            | Почему                                                                                                                    |
| ------------------------------------- | --------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------- |
| **Найти кратчайший путь в лабиринте** | BFS (если все рёбра = 1), Дейкстра (если есть веса) | Лабиринт = невзвешенный граф, поэтому BFS даёт кратчайший путь по количеству шагов; в случае разных стоимостей — Дейкстра |
| **Определить связность сети**         | BFS / DFS / Поиск компонент связности               | DFS/BFS позволяют определить доступные вершины; для всей сети — проходим все компоненты                                   |
| **Топологическая сортировка**         | DFS-based topo sort                  | Работает только для DAG; используется порядок зависимостей                                                                |


# Ответы на контрольные вопросы

## 1. Разница между матрицей смежности и списком смежности

| Критерий | Матрица смежности | Список смежности |
|---------|--------------------|------------------|
| **Память** | O(V²) | O(V + E) |
| **Проверка наличия ребра u→v** | O(1) | O(deg(u)) |
| **Добавление ребра** | O(1) | O(1) |
| **Удаление ребра** | O(1) | O(deg(u)) |
| **Добавление вершины** | Очень дорого — пересоздание матрицы | O(1) |
| **Оптимально для** | Плотных графов | Разреженных графов |
| **Недостатки** | Высокое потребление памяти | Медленнее проверка наличия ребра |
| **Преимущества** | Быстрые операции проверки | Экономия памяти |

---

## 2. Алгоритм поиска в ширину (BFS) и его применение

Поиск в ширину (BFS) — это алгоритм обхода графа, который исследует вершины слоями: сначала посещает всех соседей стартовой вершины, затем соседей этих соседей и так далее. Он использует очередь, что гарантирует, что вершины посещаются в порядке возрастания расстояния от источника.

BFS применяется для:
- нахождения кратчайшего пути в невзвешенных графах;
- проверки связности графа;
- поиска компонент связности;
- задач на минимальное количество шагов (лабиринты, сетевые маршруты);
- проверки на двудольность графа.

---

## 3. Отличия DFS от BFS и дополнительные задачи, решаемые DFS

Поиск в глубину (DFS) обходит граф, углубляясь по одному пути до конца, а затем делает откат назад. Он использует стек (неявный — в рекурсии или явный — вручную).

Отличия:
- **BFS** идёт слоями и находит кратчайшие пути в невзвешенных графах.
- **DFS** идёт вглубь, не гарантируя минимального пути, но лучше подходит для анализа структуры графа.

Задачи, решаемые DFS:
- проверка графа на наличие циклов;
- топологическая сортировка (DFS-версия);
- поиск мостов и точек сочленения;
- поиск компонент сильной связности;
- нахождение всех путей между вершинами (в небольших графах).

---

## 4. Алгоритм Дейкстры: принцип работы и ограничения

Алгоритм Дейкстры ищет кратчайшие пути во взвешенном графе без отрицательных рёбер. Он поддерживает массив расстояний и структуру данных (обычно очередь с приоритетами), которая всегда выбирает вершину с минимальной текущей оценкой расстояния. После выбора вершины её расстояние считается финальным, и происходит релаксация всех выходящих рёбер.

Почему он не работает с отрицательными весами:
- Если ребро имеет отрицательный вес, то после "финализации" расстояния до вершины может появиться путь короче, что нарушает ключевое свойство алгоритма — **локальная оптимальность становится недействительной**, и алгоритм даёт неверный результат.

---

## 5. Топологическая сортировка: определение, применимость и пример

Топологическая сортировка — это упорядочивание вершин ориентированного графа так, что все рёбра направлены слева направо (из ранних вершин в поздние). Она применима **только к DAG (ориентированным ацикличным графам)**. Если граф содержит цикл, корректного топологического порядка не существует.

Примеры задач:
- порядок выполнения задач с зависимостями;
- компиляция модулей (какие модули должны быть собраны раньше);
- планирование курсов: курс B нельзя пройти до курса A;
- построение порядка вычисления формул.


