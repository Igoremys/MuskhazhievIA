# Отчет по лабораторной работе №3
# Тема: Рекурсия

**Дата:** 2025-10-20  
**Семестр:** 3 курс, 5 семестр  
**Группа:** ПИЖ-б-о-23-2(2) 
**Дисциплина:** Анализ сложности алгоритмов  
**Студент:** Мусхажиев Игорь Александрович

---

## Цель работы
Освоить принцип рекурсии, научиться анализировать рекурсивные алгоритмы и понимать механизм работы стека вызовов. Изучить типичные задачи, решаемые рекурсивно, и освоить технику мемоизации для оптимизации рекурсивных вычислений.

---

## Теоретическая часть
Рекурсия — это метод программирования, при котором функция вызывает сама себя. Рекурсивные алгоритмы удобно использовать для решения задач с повторяющейся структурой. Однако наивная рекурсия может быть медленной и потреблять много памяти из-за глубокого стека вызовов. Мемоизация позволяет хранить промежуточные результаты и значительно ускоряет вычисления.  

Классические примеры рекурсивных задач:  
- Факториал числа  
- Числа Фибоначчи  
- Бинарный поиск в отсортированном массиве  
- Задача Ханойских башен  
- Обход файловой системы  

---

## Практическая часть

### Выполненные задачи
- [x] Задача 1: Реализован рекурсивный расчет факториала  
- [x] Задача 2: Реализован наивный и мемоизированный расчет чисел Фибоначчи  
- [x] Задача 3: Реализован рекурсивный бинарный поиск и Ханойские башни  
- [x] Задача 4: Проведен рекурсивный обход файловой системы и измерена максимальная глубина рекурсии  
- [x] Задача 5: Сравнена производительность наивной и мемоизированной рекурсии с построением графика  

---

### Ключевые фрагменты кода
```python
# Рекурсивный факториал
def factorial(n: int) -> int:
    if n < 0:
        raise ValueError("Факториал не определён для отрицательных чисел.")
    if n == 0 or n == 1:
        return 1
    return n * factorial(n - 1)  # O(n), глубина = n

# Наивная рекурсия Фибоначчи
def fibonacci(n: int) -> int:
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)  # O(2^n), глубина = n

# Мемоизированная Фибоначчи
def fibonacci_memo(n: int, memo: dict = None) -> int:
    if memo is None:
        memo = {}
    if n in memo:
        return memo[n]
    if n <= 1:
        memo[n] = n
    else:
        memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)
    return memo[n]  # O(n), глубина = O(n)

# Быстрое возведение в степень
def power(a: float, n: int) -> float:
    if n == 0:
        return 1
    if n < 0:
        return 1 / power(a, -n)
    if n % 2 == 0:
        half = power(a, n // 2)
        return half * half
    else:
        return a * power(a, n - 1)  # O(log n), глубина = O(log n)

# Рекурсивный бинарный поиск
def binary_search_recursive(arr, target, left=0, right=None):
    if right is None:
        right = len(arr) - 1
    if left > right:
        return -1
    mid = (left + right) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] > target:
        return binary_search_recursive(arr, target, left, mid - 1)
    else:
        return binary_search_recursive(arr, target, mid + 1, right)

# Ханойские башни
def hanoi(n: int, source='A', target='C', auxiliary='B', moves=None):
    if moves is None:
        moves = []
    if n == 1:
        move = f"Переместить диск 1 с {source} на {target}"
        print(move)
        moves.append(move)
    else:
        hanoi(n - 1, source, auxiliary, target, moves)
        move = f"Переместить диск {n} с {source} на {target}"
        print(move)
        moves.append(move)
        hanoi(n - 1, auxiliary, target, source, moves)
    return moves
```

---

## Результаты выполнения

### Пример работы программы
```bash
Бинарный поиск:
Элемент 7 имеет индекс: 3

Ханойские башни (3 диска):
Переместить диск 1 с A на C  
Переместить диск 2 с A на B  
Переместить диск 1 с C на B  
Переместить диск 3 с A на C  
Переместить диск 1 с B на A  
Переместить диск 2 с B на C  
Переместить диск 1 с A на C  
Обход файловой системы:
|-- main.py
|-- recursion_tasks.py
|-- memoization.py
|-- ... (другие файлы и папки)

Максимальная глубина рекурсии: 0

Сравнение времени выполнения рекурсии с мемоизацией и без:
Наивная рекурсия (35): 0.9569 сек
С мемоизацией (35): 0.0001 сек

График сохранён в файл: fibonacci_plot.png
```

---

### Характеристики ПК для тестирования
```
Процессор: 12th Gen Intel(R) Core(TM) i5-12400F 
Оперативная память: 16 GB DDR4
ОС: Windows 10
Python: 3.10.10
```

## Выводы
1.Рекурсия удобна для решения задач с повторяющейся структурой, но может быть ресурсоёмкой.
2.Мемоизация значительно ускоряет вычисления, особенно для экспоненциальных рекурсий, таких как числа Фибоначчи.
3.Рекурсивные алгоритмы позволяют наглядно решать задачи бинарного поиска, Ханойских башен и обхода файловой системы, с измерением глубины рекурсии.
4.Быстрое возведение в степень демонстрирует эффективность рекурсии даже без мемоизации — за счёт деления задачи пополам на каждом шаге.
5.Глубина рекурсии при обходе файловой системы ограничена параметром max_depth, что предотвращает переполнение стека.

---

## Ответы на контрольные вопросы
1. **Что такое базовый случай и рекурсивный шаг в рекурсивной функции? Почему отсутствие базового случая приводит к ошибке?** - Базовый случай — это условие завершения рекурсии. Рекурсивный шаг — вызов функции с уменьшенным аргументом. Без базового случая рекурсия становится бесконечной, что приводит к переполнению стека.

2. **Объясните, как работает механизм мемоизации. Как он меняет временную сложность вычисления чисел Фибоначчи по сравнению с наивной рекурсией?** - Мемоизация сохраняет уже вычисленные значения в словаре, чтобы не пересчитывать их. Это снижает временную сложность с O(2ⁿ) до O(n).

3. **В чем заключается основная проблема глубокой рекурсии и как она связана со стеком вызовов?** - Каждый рекурсивный вызов добавляет фрейм в стек. При слишком большой глубине стек переполняется, и программа аварийно завершается.

4. **Задача о Ханойских башнях решается рекурсивно. Опишите алгоритм решения для 3 дисков.** - Сначала перемещаем верхние 2 диска с исходного стержня на вспомогательный, затем самый большой — на целевой, и наконец, 2 диска — с вспомогательного на целевой.

5. **Рекурсивный и итеративный алгоритмы могут решать одни и те же задачи. Назовите преимущества и недостатки каждого подхода.** - Рекурсия: читаемость, естественность для древовидных структур; недостатки — расход памяти, риск переполнения стека.
Итерация: эффективность по памяти и скорости; недостатки — более сложная логика для некоторых задач.

---

## Приложения
- [Исходный код recursion.py](./recursion.py)
- [Исходный код recursion_tasks.py](./recursion_tasks.py)
- [Исходный код memoization.py](./memoization.py)
![График сравнения времени вычислений Fibonacci](fibonacci_comparison.png)