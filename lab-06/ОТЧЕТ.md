# Отчет по лабораторной работе №6

# Бинарные деревья поиска (BST)

**Дата:** 2025-11-25
**Семестр:** 3 курс, 1 полугодие (5 семестр)
**Группа:** ПИЖ-б-о-23-2(2)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Мусхажиев Игорь Александрович

---

## Цель работы

Изучить древовидные структуры данных и их применение. Реализовать
бинарное дерево поиска (BST), освоить операции вставки, поиска,
удаления, научиться выполнять обходы дерева, визуализировать структуру и
провести экспериментальные измерения производительности.

---

## Теоретическая часть

-   Дерево - рекурсивная структура данных.
-   BST - левое поддерево содержит элементы меньше узла, правое - больше.
-   Операции: insert, search, delete.
-   Обходы: in-order, pre-order, post-order.
-   Сложность: O(log n) в среднем, O(n) в худшем.
-   Сбалансированные деревья предотвращают вырождение.

---

## Практическая часть

### Выполненные задачи

- Реализован класс `BinarySearchTree` с итеративной вставкой (устойчивой к глубокой рекурсии).
- Реализованы операции: `insert`, `search`, `delete`.
- Реализованы методы: `find_min`, `find_max`, `height`, `is_valid_bst`.- Обходы дерева: 
    - Рекурсивные: in-order, pre-order, post-order 
    - Итеративный: in-order (с использованием стека)
- Реализована текстовая визуализация с отступами.
- Написаны unit-тесты для всех ключевых операций.
- Проведён эксперимент: 
    - Построены **сбалансированное** (случайная вставка) и **вырожденное** (отсортированная вставка) деревья.  
    - Замерено среднее время 500 операций поиска для размеров: 100, 300, 600, 1000, 1500.

---

### Ключевые фрагменты кода

**Итеративная вставка (устойчивая к глубокой рекурсии):**
```python
def insert(self, value):
    new_node = TreeNode(value)
    if self.root is None:
        self.root = new_node
        return
    current = self.root
    while True:
        if value < current.value:
            if current.left is None:
                current.left = new_node
                return
            current = current.left
        elif value > current.value:
            if current.right is None:
                current.right = new_node
                return
            current = current.right
        else:
            return  # Дубликаты игнорируются
```

---

### Пример работы программы

```bash
=== Демонстрация BST ===
Дерево:
Root: 50
    L--- 30
        L--- 20
        R--- 40
    R--- 70

In-order (рекурсия): [20, 30, 40, 50, 70]
In-order (итерация): [20, 30, 40, 50, 70]
Pre-order: [50, 30, 20, 40, 70]
Post-order: [20, 40, 30, 70, 50]

Минимум: 20
Максимум: 70
Высота: 2
Корректное BST? True

Удаление узла 30:
Root: 50
    L--- 40
        L--- 20
        R--- None
    R--- 70
```

---

## Характеристики ПК для тестирования
    ```
    Процессор: 12th Gen Intel(R) Core(TM) i5-12400F 
    Оперативная память: 16 GB DDR4
    ОС: Windows 10
    Python: 3.13.1
    ```

---

## Выводы
1. Реализована полностью функциональная структура данных **BST**.
2. Подтверждена **теоретическая разница в производительности**:  
- Сбалансированное дерево: время поиска почти не растёт с увеличением размера.  
- Вырожденное дерево: время поиска растёт линейно.
3. **Балансировка критически важна** для обеспечения эффективности в реальных приложениях.
4. Итеративные алгоритмы повышают устойчивость программы к большим данным.

---

## Ответы на контрольные вопросы
1. **Основное свойство BST?**     Левое поддерево содержит значения меньше узла, правое — больше.
2. **Алгоритм вставки и сложность**    
 Сравниваем значение с узлами, спускаемся влево/вправо до пустого места.    
Сложность: **O(log n)** (сбалансированное), **O(n)** (вырожденное).
3. **DFS vs BFS?**    
- **DFS** (в глубину): рекурсивные обходы (pre/in/post-order).    
- **BFS** (в ширину): уровень за уровнем, используется очередь.     DFS используется для анализа структуры, BFS — для поиска по уровням.
4. **Почему O(n) в вырожденном дереве?**     Потому что дерево превращается в односвязный список, высота = n.
5. **Что такое сбалансированное дерево?**     Дерево, автоматически поддерживающее высоту ~log n (например, AVL), что гарантирует **O(log n)** для всех операций даже в худшем случае.
---

## Приложения
- Исходный код
  - `binary_search_tree.py`
  - `tree_traversal.py`
  - `analysis.py`
  - `main.py`
- График:
  - `search_time_comparison.png`
