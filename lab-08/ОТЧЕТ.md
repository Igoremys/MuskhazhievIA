
# Отчет по лабораторной работе №8  
# Жадные алгоритмы

**Дата:** 2025-12-09  
**Семестр:** 3 курс, 5 семестр (1 полугодие)  
**Группа:** ПИЖ-б-о-23-2(2)  
**Дисциплина:** Анализ сложности алгоритмов  
**Студент:** Мусхажиев Игорь Александрович

---

## Цель работы
Изучить метод проектирования жадных алгоритмов, понять свойства оптимальной подструктуры и жадного выбора, реализовать классические жадные алгоритмы, провести их анализ, сравнить их с точными методами и выполнить экспериментальное исследование времени работы алгоритма Хаффмана.

---

## Теоретическая часть

**Жадный алгоритм** — это стратегия построения решения, при которой на каждом шаге принимается локально оптимальное решение в надежде достичь глобального оптимума.
Для корректности жадного подхода необходимы два условия:
1. **Свойство жадного выбора** — можно построить оптимальное решение, делая локально оптимальные выборы.
2. **Оптимальная подструктура** — оптимальное решение содержит в себе оптимальные решения подзадач.

Изучаемые алгоритмы:

- **Interval Scheduling** — выбор максимального числа непересекающихся интервалов.
- **Fractional Knapsack** — дробный рюкзак (можно брать доли предметов).
- **Huffman Coding** — построение оптимального префиксного кода.
- **Greedy Coin Change** — размен монет жадным способом (только для канонических систем).
- **Алгоритмы построения MST**: Прима и Краскала.

---

## Практическая часть

### Выполненные задачи
- [x] Реализован алгоритм выбора заявок (Interval Scheduling)  
- [x] Реализован дробный рюкзак (Fractional Knapsack)  
- [x] Реализован алгоритм Хаффмана  
- [x] Реализован жадный размен монет  
- [x] Реализованы алгоритмы Прима и Краскала для MST  
- [x] Добавлены комментарии с оценкой временной сложности  
- [x] Проведено сравнение жадного и точного решений для задачи о рюкзаке  
- [x] Выполнено экспериментальное исследование времени работы алгоритма Хаффмана  
- [x] Построены визуализации: дерево Хаффмана и график времени  
- [x] Подготовлен README.md по стандарту PEP 8  
- [x] Проект организован в соответствии с GitHub Flow   

---

## Характеристики ПК для тестирования
```
Процессор: 12th Gen Intel(R) Core(TM) i5-12400F
Оперативная память: 16 GB DDR4
ОС: Windows 10
Python: 3.13.1
```

---

## Ключевые фрагменты кода

### Алгоритм выбора заявок (Interval Scheduling)
```python
def interval_scheduling(intervals):
    intervals_sorted = sorted(intervals, key=lambda x: x[1])
    selected = []
    last_end = float('-inf')
    for start, end in intervals_sorted:
        if start >= last_end:
            selected.append((start, end))
            last_end = end
    return selected
```

### Fractional Knapsack
```python
def fractional_knapsack(items, capacity):
    items = sorted(items, key=lambda x: x[0]/x[1], reverse=True)
    total_value = 0.0
    for value, weight in items:
        if capacity <= 0:
            break
        take = min(weight, capacity)
        total_value += value * (take / weight)
        capacity -= take
    return total_value
```

### Алгоритм Хаффмана
```python
def huffman_coding(freq_dict):
    heap = [Node(char, freq) for char, freq in freq_dict.items()]
    heapq.heapify(heap)
    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        merged = Node(freq=left.freq + right.freq, left=left, right=right)
        heapq.heappush(heap, merged)
    return build_codes(heap[0])
```

### Алгоритм Краскала
```python
def kruskal_mst(edges, n):
    edges.sort(key=lambda x: x[2])
    uf = UnionFind(n)
    mst = []
    for u, v, w in edges:
        if uf.union(u, v):
            mst.append((u, v, w))
    return mst
```

---

## Результаты выполнения

### Вывод программы
```bash
=== Экспериментальное исследование времени работы Хаффмана ===
Размер    100 → время 0.000057 сек  
Размер    500 → время 0.000035 сек  
Размер   1000 → время 0.000049 сек  
Размер   2000 → время 0.000064 сек  
Размер   5000 → время 0.000115 сек  
График сохранён в файл time_vs_size.png
```

### График времени работы
График демонстрирует почти линейный рост времени выполнения алгоритма Хаффмана.  
Файл графика: **time_vs_size.png**

---

## Выводы

1. Жадные алгоритмы эффективны  и просты в реализации, но применимы только при наличии свойств жадного выбора и оптимальной подструктуры. 
2. Алгоритмы Хаффмана, Interval Scheduling и Fractional Knapsack — корректны и оптимальны. 
3. Алгоритмы Прима и Краскала успешно решают задачу MST — классический пример жадности в графах.

---

## Ответы на контрольные вопросы

1. **В чем заключается основная идея жадных алгоритмов?**  
   Жадные алгоритмы принимают локально оптимальное решение на каждом шаге, не пересматривая предыдущие решения и не заглядывая в будущее, в надежде, что последовательность таких решений приведёт к глобальному оптимуму.

2. **Почему стратегия выбора интервалов с минимальным временем окончания оптимальна?**  
   Потому что такой выбор максимально освобождает ресурс (время) для последующих заявок. Формально: если существует оптимальное решение, не начинающееся с самого рано заканчивающегося интервала, его можно заменить на этот интервал без ущерба для оптимальности (метод обмена). Это доказывает корректность жадной стратегии.

3. **Пример задач, где жадный метод работает и не работает.**  
   Работает: Хаффман, Interval Scheduling, Fractional Knapsack.  
   Не работает: 0–1 Knapsack, Размен монет в неканонических системах.

4. **Разница между дробным и дискретным рюкзаком.**  
   В дробном рюкзаке разрешено брать любую долю предмета → жадный алгоритм (по удельной ценности) оптимален.  
   В дискретном (0/1) рюкзаке предмет берётся целиком или не берётся → жадный подход не гарантирует оптимум, требуется динамическое программирование или перебор.

5. **Оптимальность алгоритма Хаффмана.**  
   Потому что он основывается на двух ключевых свойствах:
   Два наименее частых символа всегда находятся на максимальной глубине в оптимальном дереве.
   Объединение этих символов в один «суперсимвол» сохраняет оптимальность подзадачи(оптимальная подструктура).
   Это позволяет рекурсивно строить глобально оптимальное дерево жадным способом.

---

## Приложения
- Файлы проекта:
  - `greedy_algorithms.py`
  - `exact_algorithms.py`
  - `analysis.py`
  - `visualize.py`
- Графики:
  - `time_vs_size.png`
  - `huffman_tree.png`
